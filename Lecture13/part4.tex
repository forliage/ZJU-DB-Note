\section{插入和删除操作}

使用两阶段锁：
\begin{itemize}
    \item 仅当删除元组的事务对要删除的元组具有排他锁时，才可以执行删除操作。
    \item 项数据库中插入新元组的事务会获得该元组的X模式锁
\end{itemize}

插入和删除操作可能会导致幻影现象。

\noindent 扫描关系的事务（例如，查找佩里里奇所有账户余额的总和）以及在关系中插入一个元组的事务
（例如，在佩里里奇插入一个新账户）（从概念上讲）进官没有共同访问任何元组，但仍会发生冲突。

如果仅使用元组锁，则可能会产生不可串行化的调度。例如，扫描事务看不到新账户，
但会读取更新事务写入的其它一些元组。

扫描该关系的事务正在读取指示该关系包含哪些元组的信息，而插入元组的事务会更新相同的信息。
该信息应被加锁。

一种解决方案：将一个数据项与该关系关联起来，以表示关于该关系包含哪些元组的信息；
扫描该关系的事务在该数据项上获取共享锁。插入或删除元组的事务在该数据项上获取排他锁（注意：数据项上的锁与
单个元组上的锁不冲突）

上述协议在插入/删除操作方面提供的并发度非常低。

索引锁定协议通过对某些索引桶加锁，在防止幻象现象的同时提供了更高的并发度。

\noindent\textbf{索引锁定协议}

每个关系必须至少一个索引。对关系的访问必须仅通过该关系的索引之一进行。

执行查找操作的事务$T_i$必须以共享(S)模式锁定其访问的所有索引桶。

事务$T_i$在未更新关系$r$的所有索引情况下，不得将元组$t_i$插入到关系$r$中。

$T_i$必须对每个索引执行查找操作，以找到所有可能包含指向元组$t_i$的指针的索引桶(假设该元组已经存在)，
并以X模式锁定这些索引桶。$T_i$还必须以X模式锁定其修改的所有索引桶。

必须遵守两阶段锁定协议的规则。

