\section{死锁方案}

\subsection{死锁处理}

如果存在一组事务，使得该组中的每个事务都在等待该组中的另一个事务，则系统发生死锁。

如何处理？死锁预防/死锁检测与死锁恢复

\subsection{死锁预防}

死锁预防协议可确保系统永远不会进入死锁状态。一些预防策略：

1) 要求每个事务在开始执行前锁定其所有数据项（预先声明）——保守两阶段锁协议（要么全部锁定，要么都不锁定）。

2) 对所有数据项施加部分顺序，并要求事务只能按此顺序锁定数据项（基于图协议）——因此永远不会形成循环

在等待-死亡和伤口-等待方案中，回滚的事务都会使用其原始时间戳重新启动。因此，较旧的事务优先于较新的事务，从而避免了饥饿问题。

基于超时的方案：
\begin{itemize}
    \item 事务仅在指定的时间内等待锁。之后，等待超时，事务回滚。
    \item 因此不可能发生死锁
    \item 实现简单；但可能会出现饥饿问题。此外，很难确定合适的超时时间间隔值。
\end{itemize}

以下方案仅为预防死锁而使用事务时间戳：

等待-死亡方案——非抢占式：较旧的事务可能会等待较新的事务释放数据项。较新的事务从不等待较旧的事务；相反，它们会被回滚。

伤害—等待方案——抢占式：较旧的事务会导致较新事务的旧事务伤口（强制回滚），而不是等待它。较新的事务可能会等待较旧事务。与等待-死亡方案相比，回滚次数可能更少，回来时的时间戳仍是之前的。

\subsection{死锁检测}

死锁可以用等待图来描述，该图由一对$G=(V,E)$组成，$V$是一组顶点(系统中的所有事务)，$E$是一组边；每个元素都是一个有序对$T_i\to T_j$
如果$T_i\to T_j$在$E$中，那么从$T_i$到$T_j$存在一条有向边，这意味着$T_i$正在等待$T_j$释放一个数据项。

当$T_i$请求一个当前由$T_j$持有的数据项时，边$T_iT_j$会被插入到等待图中。只有当$T_j$不再持有$T_i$所需的
数据项时，这条边才会被移除。

当且仅当等待图存在环时，系统处于死锁状态。必须定期调用死锁检测算法查找环。

\subsection{死锁恢复}

必须回滚某些事务（将其作为牺牲品）以打破死锁。选择成本最小的事务作为牺牲品。

回滚——确定将事务回滚多远。
\begin{itemize}
    \item 完全回滚：中止事务，然后重新启动它
    \item 部分回滚：仅将事务回滚到打破死锁所需的程度更为有效
\end{itemize}

如果总是选择同一事务作为牺牲品，就会发生饥饿现象。将回滚次数纳入成本因素以避免饥饿。