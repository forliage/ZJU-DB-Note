\section{多粒度}

\subsection{多粒度}

为方便起见，允许数据项根据需求以不同大小进行加锁——即多粒度。

定义一个数据粒度层次结构，其中小粒度嵌套在大粒度中，并且可以用图形表示为一棵树

当一个事务显式地对树中的一个节点加锁时，它会以相同的模式隐式地对该节点的所有后代节点加锁。

加锁粒度（进行加锁的树的层级）：细粒度：高并发，高加锁开销；粗粒度：低锁开销，低并发

\subsection{意向锁}

问题：$T_1$在$X$锁中锁定了$r_{a_1}$，$T_2$在$S$锁中锁定了$F_b$。现在$T_3$希望在$S$锁中锁定$F_a$.
$T_4$希望在$S$锁中锁定整个DB。

在显式锁定一个节点之前，会对该节点的所有祖先节点设置意向锁。

意向锁允许在$S$或$X$模式下锁定更高级别的节点，而无需检查所有子节点。

\subsection{意向锁模式}

存在三种具有多种粒度的意向锁模式：
\begin{itemize}
    \item 意向共享锁（IS）：表示在树的较低层级使用共享锁进行显式锁定（表明其后代存在S锁）
    \item 意向排他锁（IX）：表示在较低层级使用排他锁进行显式锁定（表明其后代存在X锁）
    \item 共享意向排他锁（SIX）：以该节点为根的子树以共享模式进行显式锁定，并且在较低层级使用排他模式锁进行显式锁定。
\end{itemize}

\subsection{多粒度锁机制}

事务$T_i$可以使用以下规则锁定节点$Q$：
\begin{enumerate}
    \item 必须遵守锁兼容性矩阵
    \item 必须先锁定树的根节点，并且可以以任何模式锁定。
    \item 只有当节点$Q$的父节点当前被$T_i$以IX或IS模式锁定时，$T_i$才能以S或IS模式锁定节点$Q$
    \item 只有当节点$Q$的父节点当前被$T_i$以IX或SIX模式锁定时，$T_i$才能以X，SIX或IX模式锁定节点$Q$
    \item $T_i$仅在之前未解锁任何节点时才能锁定一个节点（即$T_i$是两个阶段的）
    \item $T_i$仅在$Q$的任何子节点当前都未被$T_i$锁定时才能解锁节点$Q$
\end{enumerate}

注意，锁时按照从根到叶的顺序获取的，而释放则是按照从叶到根的顺序进行的。（加锁自顶向下，解锁自下而上，且遵守2PL协议）

优点：增强并发性，降低加锁开销。