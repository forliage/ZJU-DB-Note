\section{缓冲区管理}

\subsection{日志记录缓冲}

通常情况下，向稳定存储的输出以块为单位，并且通常日志记录比较小得多。

因此，日志记录被缓冲在主内存中，而不是直接输出到稳定存储。

当日志记录满足以下情况时，将其输出到稳定存储：
\begin{enumerate}
    \item 缓冲区中的日志记录块已满
    \item 或者执行了日志强制操作
    \item 例如，检查点发生
\end{enumerate}

强制日志通过将事务的所有日志记录（包括提交记录<$T_i$ commit>）强制写入稳定存储来提交事务。

因此，可以使用一次输出操作输出多条日志记录，从而降低I/O成本。

如果对日志记录进行缓冲，则必须遵循以下4条规则：
\begin{enumerate}
    \item 日志记录按照其创建顺序输出到稳定存储中
    \item 事务$T_i$仅当日志记录<$T_i$ commit>已输出到稳定存储时才进入提交状态
    \item 在<$T_i$ commit>可以输出到稳定存储之前，与$T_i$相关的所有日志记录都必须已输出到稳定存储。
    \item 在将主内存中的一个数据块输出带数据库之前，与该数据块中的数据相关的所有日志记录都必须已输出到稳定存储（日志应先于数据写到磁盘）
\end{enumerate}

此规则称为先写日志规则(write-ahead logging rule)或WAL。严格来说，先写日志规则仅要求输出撤销信息。

\subsection{数据库缓冲}

数据库维护数据块的内存缓冲区。
\begin{itemize}
    \item 当需要一个新的数据块时，如果缓冲区已满，则需要从缓冲区中移除一个现有的数据块
    \item 如果选择移除的数据块已被更新，则必须将其输出到磁盘
\end{itemize}

恢复算法支持非强制策略，即事务提交时，更新的数据块不必写入磁盘。

强制策略：要求在提交时写入更新的数据块：提交成本更高。

恢复算法支持窃取策略，即包含未提交事务更新的块可以在事务提交之前写入磁盘。

如果将包含未提交更新的块输出到磁盘，首先会将包含这些更新的撤销信息的日志记录输出到稳定存储的日志中。

当一个块被输出到磁盘时，该块不应有正在进行的更新。可按如下方式确保这一点：
\begin{itemize}
    \item 在写入数据项之前，事务会获取包含该数据项的块的X锁
    \item 写入完成后即可释放锁（这种短时间持有的锁称为latches）
\end{itemize}

将一个数据块输出到磁盘：
\begin{itemize}
    \item 首先获取该数据块上的X锁latches（确保该数据块上没有正在进行的update操作）
    \item 然后执行日志刷新
    \item 然后将数据块输出到磁盘
    \item 最后松开模块上的latches
\end{itemize}

数据库缓冲区可以通过以下两种方式实现：
\begin{itemize}
    \item 在为数据库预留的实际主存区域中
    \item 或者在虚拟内存中
\end{itemize}

在预留主存中实现缓冲区存在缺点：
\begin{itemize}
    \item 内存预先在数据库缓冲区和应用程序之间进行了划分，限制了灵活性
    \item 需求可能会发生变化，尽管操作系统最清楚在任何时候应该如何划分内存，但它无法改变内存的划分方式
\end{itemize}

尽管存在一些缺点，但数据库缓冲区通常在虚拟内存中实现：
\begin{itemize}
    \item 当操作系统需要换出一个已修改的页面时，该页面会被写入磁盘的交换空间
    \item 当数据库决定将缓冲区页面写入磁盘时，缓冲区页面可能在交换空间中，可能需要从磁盘的交换空间读取并输出到磁盘上的数据库，从而导致额外的I/O
    \item 理想情况下，当操作系统需要从缓冲区患处一个页面时，它应该将控制权交给数据库，而数据库又应该：
       \begin{enumerate}
           \item 如果页面被修改，将其输出到数据库而非交换空间（确保先输出日志记录），如果它被修改
           \item 从缓冲区释放该页面，供操作系统使用。这样可以避免双重分页，但常见的操作系统不支持这种功能。
       \end{enumerate}
\end{itemize}