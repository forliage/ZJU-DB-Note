\section{基于日志的恢复}

\subsection{基于日志的恢复}

日志保存在为稳定存储的设备上“日志是一系列日志记录，用于记录数据库的更新活动。

当事务$T_i$开始时，它通过写入一个<$T_i$ start>日志记录来注册本身。

在$T_i$执行写操作write(X)之前，写入一条日志记录$<T_i,X,V_1,V_2>$其中$V_1$是写操作之前$X$的值（旧值），
$V_2$是要写入$X$的值（新值）。

当$T_i$完成其最后一条语句时，会写入日志记录<$T_i$ commit>

使用日志的两种方法：延迟数据库修改；立即数据库修改。

\subsection{延迟数据库修改}

延迟数据库修改方案将所有修改记录到日志中，但将所有写入操作推迟到部分提交后。一般不采用。

假设事务按顺序执行。事务通过向日志写入<$T_i$ start>记录来启动。

写(X)操作会导致写入一条$\log$ 记录$<T_i,X,V>$，其中$V$是$X$的新值。注意：此方案不需要旧值。

此时不会在$X$上执行写入操作，而时将其推迟。当$T_i$部分提交时，<$T_i$ commit>会被写入日志。最后，
读取日志记录并用于实际执行之前推迟的写入操作。

\subsection{即时数据库修改}

即时修改方案允许在事务提交之前将未提交事务的更新写入缓冲区或磁盘本身，写的时间不受commit限制。

在写入数据项之前，必须先写入更新日志记录。我们假设日志记录直接输出到稳定存储。

在事务提交之前或之后的任何时间都可以将更新后的块输出到为你的难过存储。

块的输出顺序可能与编写顺序不同。

\noindent\textbf{如何恢复？}

恢复过程有两个操作而非一个：
\begin{itemize}
    \item undo($T_i$)从$T_i$的最后一条日志记录开始逆向操作，将$T_i$更新的所有数据项的值恢复为其旧值。
    \item redo($T_i$)从$T_i$的第一条日志记录开始正向操作，将$T_i$更新的所有数据项的值设置为新值。
\end{itemize}

两个操作都必须是幂等的：也就是说，即使该操作执行多次，其效果与执行一次相同。恢复期间操作可能会重新执行，因此有此需求。

故障恢复时：
\begin{itemize}
    \item 如果日志包含记录<$T_i$ start>，但不包含记录<$T_i$ commit>，则事务$T_i$需要回滚
    \item 如果日志中同时包含记录<$T_i$ start>和记录<$T_i$ commit>，则事务$T_i$需要重做。
\end{itemize}

先执行回滚操作，再执行重做操作。

\subsection{检查点}

重做/撤销日志中记录的所有事务可能非常缓慢：
\begin{enumerate}
    \item 如果系统已经运行了很长时间，处理真个日志会很耗时
    \item 我们可能会不必要地重做那些已经将更新输出到数据库的事务
\end{enumerate}

通过定期执行检查点操作来简化恢复过程：
\begin{enumerate}
    \item 将当前驻留再主内存中的所有日志记录输出到稳定存储设备上
    \item 将所有修改过的缓冲区块输出到磁盘
    \item 将日志记录<checkpoint $L$>写入稳定存储，其中$L$是检查点时刻所有活跃事务的列表：进行检查点操作时，所有更新都会停止
\end{enumerate}

在恢复过程中，我们只需考虑在检查点之前开始的最近一次事务$T_i$以及在$T_i$之后开始的事务。
\begin{itemize}
    \item 从日志末尾向后扫描，以找到最近的<checkpoint $L$>记录 
    \item 只有处于$L$状态或在检查点之后开始的事务才需要重做或撤销
    \item 在检查点之前提交或中止事务，其所有更新已输出到稳定存储中。
\end{itemize}

日志的某些早期部分可能用于撤销操作：
继续向后扫描，直到为$L$中的每个事务$T_i$找到一条记录<$T_i$ start>
早于上述最早的<$T_i$ start>记录的$\log$部分不需要用于恢复，可随时擦除。